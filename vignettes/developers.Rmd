---
title: "Translation for package developers"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Translation for package developers}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette is aimed at package developer; if you're the translator of a package (or just want to understand how it looks from their site), you start with `vignette("translators")`.

Before we get into the details lets review the basic process:

-   Run `po_extract()` to extract all translatable messages from your R and C code.
    This creates a `.pot` (po template) file that contains every translatable message.

-   Use `po_create()` to generate a `.po` file for each language that your messages will be translated to.
    A `.po` file consists of pair of lines like:

        msgid "This is the message in English"
        msgstr ""

-   Pass the `.po` file on to translators who replace each `msgstr` line with the appropriate translation:

        msgid "This is the message in English"
        msgstr "This is the message in another language"

-   Use `po_compile()` to turn the plain text `.po` files into binary `.mo` files that are distributed with your package.

In this vignette, while you'll learn how to use the `po_` functions to generate the various files needed for translation, the focus will be on writing messages that can be effectively translated.

```{r setup}
library(potools)
```

## Extraction

There are two primary styles for describing which messages should be translated, as defined by the style argument to `po_extract()`:

-   `base`: the base style assumes that every call to `message()`, `warning()`, and `error()` should be translated.
    The advantage of this style is that it's fast to get up and going with your existing code.

-   `explicit`: the explicit style requires you to flag any string to be translated with `gettext()` or `tr_()`.
    The advantage of this style is that it lets you explicitly flag whether or not you've reviewed a message and deemed it ready for translation.

In this vignette, I'll primarily use the explicit style because it makes it very clear what manual.
I'll use manual in many of the examples here, just to make it crystal clear what needs to be translated.
I'll use of glue, since its style of interpolation provides additional context that's useful for translators.

```{r}
tr_ <- function(...) {
  gettext(paste0(...), domain = "R-potools")
}
library(glue)
```

## Writing good messages

The following advice is inspired by the "[Preparing translatable strings](https://www.gnu.org/software/gettext/manual/html_node/Preparing-Strings.html#Preparing-Strings%20(Inspired%20by%20from%20))" of the gettext manual.
This advice, and the underlying tooling, assume that the error messages including in your source code are in English.
Most of the advice will apply to other languages as well, although you're more likely to be aware of variation between languages than a mono-lingual English speaker.

### Write full sentences

Generally, you should strive to make sure that each message comes from a single string (i.e. lives within a single "").
Instead of building up a message from small fragment using `paste()` or friends:

```{r}
name <- "Hadley"
paste0(tr_("Good"), " ", tr_("morning"), " ", name, "!")
```

There are two reasons that you should try to write complete sentences.
Firstly, when working with `.po` files, translators see each individual string without context, and they may be in a different order to the original source:

    msgid "!"
    msgstr ""

    msgid "morning"
    msgstr ""

    msgid "Good"
    msgstr ""

This can lead either to a poor translation or an expensive journey to the source code to get more context.
More importantly, prose is not like code: you can't reliably build up sentences from small fragments of text.
And even if you can do figure out how to do it in English, it's unlikely the same form will work for other languages.

Instead it's better to build the complete message in a single string with `glue()` or `sprintf()`:

```{r}
glue(tr_("Good morning {name}"))
sprintf(tr_("Good morning %s"), name)
```

This gives the translator the context to create a good translation and the freedom to change word order to make a grammatically correct sentence in their language.

    msgid "Good morning {name}!"
    msgstr ""

### `sprintf()` vs `glue()`

In R, there are two common ways to interpolate variables into a string: `sprinf()` and `glue()`.
The are pros and cons of each:

-   Using `glue()` requires an addition, if lightweight, dependency, but gives the translator more context (assuming you use informative names for local variables), and makes it easy to rearrange interpolated components:

        msgid "{first} {second} {third}"
        msgstr "{third} {first} {second}"

    Bringing the name of the variable out of the translated string is both a curse and a blessing.
    On the downside, it gives the translator less context, but on the plus side it means that you can rename variables without worrying that the translated code will break.

-   `sprintf()` is built into base R, so is always available.
    The downside is that it can be hard to figure out what `%d` or `%s` refers to and it's a little harder to rearrange components because the syntax uses `1$`, `2$`, etc which is a little harder to visually parse.

        msgid "%s %s %s"
        msgstr "%3$s %1$s %2$s"

### Multi-component sentences

What happens if your translation requires interleaving multiple pieces of data?
Take, for example, this seemingly simple greeting function:

```{r}
greet <- function(name, time_of_day) {
  paste0(tr_("Good"), " ", time_of_day, " ", name, "!")
}
greet("Hadley", tr_("morning"))
greet("Hadley", tr_("afternoon"))
greet("Hadley", tr_("evening"))
```

It doesn't even work for French, a language that's relatively close to English.
There are two related challenges: in French, both good morning and good afternoon translate to "bonjour" (literally "good day") even though in French has different words for morning and afternoon.
By translating individual components there's no way to capture the vagaries of language for greetings.

A better approach would be to define a fixed number of time points and accompanying messages:

```{r}
greet <- function(name, time_of_day) {
  switch(time_of_day,
    morning = glue(tr_("Good morning {name}!")),
    afternoon = glue(tr_("Good afternoon {name}!")),
    evening = glue(tr_("Good evening {name}!"))
  )
}
```

    msgstr: "Good morning {name}!"
    msgid: "Bonjour {name}!"

    msgstr: "Good afternoon {name}!"
    msgid: "Bonjour {name}!"

    msgstr: "Good evening {name}!"
    msgid: "Bonsoir {name}!"

(And even here the context is important; you can use bonjour only as a greeting, bonsoir can be used as both a greeting and a farewell, and you might use bon aprém as a farewell in the afternoon.)

Greetings are particularly challenging to translate: different languages break the day up differently, or the time of day might not even be the most important factor in forming the greeting.
Fortunately most of the messages that you generate for R packages will not require this level of nuance.

### Un-translatable content

You can also use interpolation to avoid including un-translatable components like URLs or email addresses into a message.
This is good practice because it saves work for the translators, makes it easier for them to see changes to the text, and avoids the chance of a translator accidentally introducing a typo.

```{r}
# Instead of this:
tr_("See <https://r-project.org> to learn more")
# Try this:
url <- "https://r-project.org"
glue(tr_("See <{url}> to learn more"))
```

Similarly, if you're generating strings to include in HTML, avoid including the html in the string, and instead translate just the words:

```{r}
# Instead of this:
tr_("<a href='/index.html'>Home page</a>")
# Try this:
paste0("<a href='/index.html'>", tr_("Home page"), "</a>")
```

Generally, you want to help the translator spend as much time as possible helping you out.

### Plurals

In English, we use a different form for most nouns depending on whether there's one item (the singular) or more than one item (the plural, also use for zero items).
So you might be tempted to construct a sentence like this:

```{r}
cows <- function(n) {
  if (n == 1) {
    paste0(n, " cow") 
  } else { 
    paste0(n, " cows")
  }
}
paste("I have ", cows(0))
paste("I have ", cows(1))
paste("I have ", cows(2))
```

But this doesn't always work, even in English:

```{r}
paste0("There are ", cows(0), " in the field")
paste0("There are ", cows(1), " in the field")
```

So really we want to follow the advice above and construct a full sentence:

```{r}
field_cows <- function(n) {
  if (n == 1) {
    fmt <- tr_("There is {n} cow in the field")
  } else {
    fmt <- tr_("There are {n} cows in the field")
  }
  glue(fmt)
}
```

But there's an additional wrinkle here: while English has singular and plural, other languages have different forms.
So we need to use a different helper: `ngettext(n, singular, plural)`:

```{r}
field_cows <- function(n) {
  glue(ngettxt(n,
    "There is {n} cow in the field",
    "There are {n} cows in the field"
  ))
}
```

`ngettext()` generates a special form in the `.po` file, which shows both singular and plural forms:

    msgid "There is {n} cow in the field"
    msgid_plural "There are {n} cows in the field"

Then the translator can supply any number of translations.
Languages that don't have plurals (e.g. Chinese) only need to supply a single translation:

    msgid "There is {n} cow in the field"
    msgid_plural "There are {n} cows in the field"
    msgstr[0] "田裡有{n}頭牛"

Russian has three forms, so it gets three entries (roughly 1, 2-4, and everything else):

    msgid "There is {n} cow in the field"
    msgid_plural "There are {n} cows in the field"
    msgstr[0] "В поле {n} коров"
    msgstr[1] "В поле {n} корова"
    msgstr[2] "В поле {n} коровы"

Slovenian and Serbian have four forms, Irish has five forms (learn more at [bitesize Irish](https://t.co/8f7BsTnlJ7?amp=1)) and Arabic has six forms.
The rules that define which number get which message are quite complex and encoded in the "plural form" that's recorded at the top of the `.po` file and looks something like `(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20)? 1 : 2).` However, this is something the translators need to worry about not you, and as speakers of the language they should find it easier to puzzle out the rules.
