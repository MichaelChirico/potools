---
title: "Translation for package developers"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Translation for package developers}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(glue)
```

This vignette is aimed at package developer; if you're the translator of a package (or just want to understand how it looks from their site), you start with `vignette("translators")`.

Before we get into the details lets review the basic process:

-   You run `po_extract()` to extract all translatable messages from your R and C code.
    This creates a `.pot` (po template) file that contains every translatable message.

-   A translator calls `po_create()` to generate a `.po` file for their language.
    A `.po` file consists of pair of lines like:

        msgid "This is the message in English"
        msgstr ""

    They then replace each `msgstr` line with the appropriate translation:

        msgid "This is the message in English"
        msgstr "This is the message in another language"

-   Either you or the translator uses `po_compile()` to turn the plain text `.po` files into binary `.mo` files that are distributed with your package.

This vignette will show you how to use the `po_extract()` and teach you how write messages that can be effectively translated.

```{r setup}
library(potools)
```

## Extraction

There are two primary styles for describing which messages should be translated, as defined by the style argument to `po_extract()`:

-   The `base` style assumes that all call to `message()`, `warning()`, and `error()` should be translated.
    The advantage of this style is that it's fast to get up and going with minimal changes to existing code.

-   The `explicit` style only translates calls to `gettext()`, `ngettext()`, and `tr_()`.
    The advantage of this style is that it lets you explicitly flag whether or not you've reviewed a message and deemed it ready for translation.
    It's also easy to use with other packages like glue.

### Base style

The base style captures messages the base functions that include built-in translation capabilities: `message()`, `warning()`, and `stop()`.
It does not, however, translate `cat()`, which is commonly used to print to the console.
It also captures messages from generic translation functions `gettext()` and `ngettext().`

`message()`, `warning()` and `stop()` concatenate the components of `…`:

```{r, error = TRUE}
message("This", " is", " a", " message")
warning("This", " is", " a", " warning")
stop("This", " is", " an", " error")
```

However, as you'll learn shortly, this style is unlikely to generate messages that are easily translated, so `po_extract(style = "base")` will also capture messages from `messagef()`, `warningf()`, and `stopf`().
These are equivalents to `message()`, `warnings()`, and `stop()` that use `sprintf()` style (hence the `f` suffix).
If you want to use these functions, you'll need to copy their definitions from below:

```{r}
messagef <- function(fmt, ..., appendLF = TRUE) {
  msg <- gettextf(fmt, ..., domain = "R-{mypackage}")
  message(msg, domain = NA, appendLF = appendLF)
}

warningf <- function(fmt, ..., immediate. = FALSE, noBreaks. = FALSE) {
  msg <- gettextf(fmt, ..., domain = "R-{mypackage}")
  warning(msg, 
    domain = NA, 
    call. = FALSE, 
    immediate. = immediate., 
    noBreaks. = noBreaks.
  )
}

stopf <- function(fmt, ...) {
  msg <- gettextf(fmt, ..., domain = "R-{mypackage}")
  stop(msg, domain = NA, call. = FALSE)
}
```

### Explicit style

The explicit style only captures messsages that explicitly flagged for translation.
This includes the base functions `gettext()` and `ngettext()`, but also a `tr_()` function that you'll need to define yourself:

```{r}
tr_ <- function(...) {
  enc2utf(gettext(paste0(...), domain = "R-{mypackage}"))
}
```

In the future, we will provide automated ways to identify strings that haven't been translated and probably should be.

I'll use the explicit style in this vignette because it makes it very clear what is being translated.
I'll use of glue, since its style of interpolation provides additional context that's useful for translators.

### Next steps

Once you've decided which style to use, record it in your description:

    Config/potools/style: explicit

And then run `po_extract()` to generate the `.pot` file.
It's a good idea to take a look at this file and read through some of the extract messages --- particularly if you've use base style, you're likely to discover a bunch of messages that are hard to understand without more context.
Now it's time to learn how to write messages that can be easily translated.

## Writing good messages

The following advice is inspired by the "[Preparing translatable strings](https://www.gnu.org/software/gettext/manual/html_node/Preparing-Strings.html#Preparing-Strings%20(Inspired%20by%20from%20))" of the gettext manual.
This advice, and the underlying tooling, assume that the error messages including in your source code are in English.
Most of the advice will apply to other languages as well, although you're more likely to be aware of variation between languages than a mono-lingual English speaker.

### Write full sentences

Generally, you should strive to make sure that each message comes from a single string (i.e. lives within a single "").
Instead of building up a message from small fragment using `paste()` or friends:

```{r}
name <- "Hadley"
paste0(tr_("Good"), " ", tr_("morning"), " ", name, "!")
```

There are two reasons that you should try to write complete sentences.
Firstly, when working with `.po` files, translators see each individual string without context, and they may be in a different order to the original source:

    msgid "!"
    msgstr ""

    msgid "morning"
    msgstr ""

    msgid "Good"
    msgstr ""

This can lead either to a poor translation or an expensive journey to the source code to get more context.
More importantly, prose is not like code: you can't reliably build up sentences from small fragments of text.
And even if you can do figure out how to do it in English, it's unlikely the same form will work for other languages.

Instead it's better to build the complete message in a single string with `glue()` or `sprintf()`:

```{r}
glue(tr_("Good morning {name}"))
sprintf(tr_("Good morning %s"), name)
```

This gives the translator the context to create a good translation and the freedom to change word order to make a grammatically correct sentence in their language.

    msgid "Good morning {name}!"
    msgstr ""

### `sprintf()` vs `glue()`

In R, there are two common ways to interpolate variables into a string: `sprinf()` and `glue()`.
The are pros and cons of each:

-   Using `glue()` requires an addition, if lightweight, dependency, but gives the translator more context (assuming you use informative names for local variables), and makes it easy to rearrange interpolated components:

        msgid "{first} {second} {third}"
        msgstr "{third} {first} {second}"

    Bringing the name of the variable out of the translated string is both a curse and a blessing.
    On the downside, it gives the translator less context, but on the plus side it means that you can rename variables without worrying that the translated code will break.

-   `sprintf()` is built into base R, so is always available.
    The downside is that it can be hard to figure out what `%d` or `%s` refers to and it's a little harder to rearrange components because the syntax uses `1$`, `2$`, etc which is a little harder to visually parse.

        msgid "%s %s %s"
        msgstr "%3$s %1$s %2$s"

### Multi-component sentences

What happens if your translation requires interleaving multiple pieces of data?
Take, for example, this seemingly simple greeting function:

```{r}
greet <- function(name, time_of_day) {
  paste0(tr_("Good"), " ", time_of_day, " ", name, "!")
}
greet("Hadley", tr_("morning"))
greet("Hadley", tr_("afternoon"))
greet("Hadley", tr_("evening"))
```

It doesn't even work for French, a language that's relatively close to English.
There are two related challenges: in French, both good morning and good afternoon translate to "bonjour" (literally "good day") even though in French has different words for morning and afternoon.
By translating individual components there's no way to capture the vagaries of language for greetings.

A better approach would be to define a fixed number of time points and accompanying messages:

```{r}
greet <- function(name, time_of_day) {
  switch(time_of_day,
    morning = glue(tr_("Good morning {name}!")),
    afternoon = glue(tr_("Good afternoon {name}!")),
    evening = glue(tr_("Good evening {name}!"))
  )
}
```

    msgstr: "Good morning {name}!"
    msgid: "Bonjour {name}!"

    msgstr: "Good afternoon {name}!"
    msgid: "Bonjour {name}!"

    msgstr: "Good evening {name}!"
    msgid: "Bonsoir {name}!"

(And even here the context is important; you can use bonjour only as a greeting, bonsoir can be used as both a greeting and a farewell, and you might use bon aprém as a farewell in the afternoon.)

Greetings are particularly challenging to translate: different languages break the day up differently, or the time of day might not even be the most important factor in forming the greeting.
Fortunately most of the messages that you generate for R packages will not require this level of nuance.

### Un-translatable content

You can also use interpolation to avoid including un-translatable components like URLs or email addresses into a message.
This is good practice because it saves work for the translators, makes it easier for them to see changes to the text, and avoids the chance of a translator accidentally introducing a typo.

```{r}
# Instead of this:
tr_("See <https://r-project.org> to learn more")
# Try this:
url <- "https://r-project.org"
glue(tr_("See <{url}> to learn more"))
```

Similarly, if you're generating strings to include in HTML, avoid including the html in the string, and instead translate just the words:

```{r}
# Instead of this:
tr_("<a href='/index.html'>Home page</a>")
# Try this:
paste0("<a href='/index.html'>", tr_("Home page"), "</a>")
```

Generally, you want to help the translator spend as much time as possible helping you out.

### Plurals

In English, we use a different form for most nouns depending on whether there's one item (the singular) or more than one item (the plural, also use for zero items).
So you might be tempted to construct a sentence like this:

```{r}
cows <- function(n) {
  if (n == 1) {
    paste0(n, " cow") 
  } else { 
    paste0(n, " cows")
  }
}
paste("I have ", cows(0))
paste("I have ", cows(1))
paste("I have ", cows(2))
```

But this doesn't always work, even in English:

```{r}
paste0("There are ", cows(0), " in the field")
paste0("There are ", cows(1), " in the field")
```

So really we want to follow the advice above and construct a full sentence:

```{r}
field_cows <- function(n) {
  if (n == 1) {
    fmt <- tr_("There is {n} cow in the field")
  } else {
    fmt <- tr_("There are {n} cows in the field")
  }
  glue(fmt)
}
```

But there's an additional wrinkle here: while English has singular and plural, other languages have different forms.
So we need to use a different helper: `ngettext(n, singular, plural)`:

```{r}
field_cows <- function(n) {
  glue(ngettxt(n,
    "There is {n} cow in the field",
    "There are {n} cows in the field"
  ))
}
```

`ngettext()` generates a special form in the `.po` file, which shows both singular and plural forms:

    msgid "There is {n} cow in the field"
    msgid_plural "There are {n} cows in the field"

Then the translator can supply any number of translations.
Languages that don't have plurals (e.g. Chinese) only need to supply a single translation:

    msgid "There is {n} cow in the field"
    msgid_plural "There are {n} cows in the field"
    msgstr[0] "田裡有{n}頭牛"

Russian has three forms, so it gets three entries (roughly 1, 2-4, and everything else):

    msgid "There is {n} cow in the field"
    msgid_plural "There are {n} cows in the field"
    msgstr[0] "В поле {xn} корова"
    msgstr[1] "В поле {n} коровы"
    msgstr[2] "В поле {n} коров"

Slovenian and Serbian have four forms, Irish has five forms (learn more at [bitesize Irish](https://www.bitesize.irish/blog/counting/)) and Arabic has six forms.
The rules that define which number get which message are quite complex and encoded in the "plural form" that's recorded at the top of the `.po` file and looks something like `(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20)? 1 : 2).` However, this is something the translators need to worry about not you, and as speakers of the language they should find it easier to puzzle out the rules.

### Collapsed lists

If you need to enumerate a list of options, you could use the [and](https://github.com/rossellhayes/and) package:

```{r, eval = FALSE}
library(and)
values <- c("first", "middle", "last")
or(values)
#> [1] "first, middle, and last"

# lang is normally retrieve automatically from the environemtn
# overriding it here to show what a translation looks like:
or(values, lang = "fr")
#> [1] "first, middle ou last"
```

You might use this with glue:

```{r, eval = FALSE}
glue(tr_("`x` must be or of {and(values)}"))
#> `x` must be or of first, middle and last
```
